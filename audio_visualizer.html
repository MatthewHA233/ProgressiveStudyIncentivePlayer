<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘å¯è§†åŒ–</title>
    <style>
        body { margin: 0; background: transparent; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; background: transparent; }
        
        /* æ§åˆ¶åŒºåŸŸæ”¹ä¸ºå‚ç›´æ’åˆ—ï¼Œå¹¶é»˜è®¤éšè— */
        #controls { 
            position: fixed; 
            top: 20px; 
            left: 20px; 
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            display: none; /* é»˜è®¤éšè—æ§åˆ¶åŒºåŸŸ */
        }
        
        button { 
            padding: 10px; 
            width: 100%;
            display: block; 
        }
        
        #statusInfo { 
            position: fixed; 
            top: 100px; 
            left: 20px; 
            color: white; 
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            display: none;
        }
        
        /* æ­Œæ›²åç§°æ˜¾ç¤ºæ ·å¼ - è¶…å¼ºå…‰æ™•ç‰ˆæœ¬ */
        #songTitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 36px;
            color: rgba(255, 255, 255, 1); /* çº¯ç™½è‰²æ–‡å­— */
            text-align: center;
            padding: 8px 20px;
            border-radius: 30px;
            background-color: transparent; /* å®Œå…¨é€æ˜èƒŒæ™¯ */
            text-shadow: 0 0 30px rgba(255, 255, 255, 1), 
                         0 0 50px rgba(255, 255, 255, 0.9),
                         0 0 70px rgba(200, 230, 255, 0.8),
                         0 0 100px rgba(140, 200, 255, 0.7); /* æå¼ºå…‰æ™•æ•ˆæœ */
            opacity: 1;
            transition: all 0.1s ease; /* æ›´å¿«çš„è¿‡æ¸¡æ•ˆæœï¼Œæ›´å¥½åœ°è·ŸéšéŸ³ä¹èŠ‚å¥ */
            pointer-events: none;
            z-index: 5;
            letter-spacing: 2px;
        }
        
        /* éŸ³é‡æ§åˆ¶å™¨æ ·å¼ */
        #volumeControl {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px 20px; /* å¢åŠ å†…è¾¹è· */
            border-radius: 30px; /* å¢å¤§åœ†è§’ */
            backdrop-filter: blur(5px);
        }
        
        #volumeInput {
            width: 120px; /* å¢å¤§å®½åº¦ä¸ºåŸæ¥çš„3å€ */
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; /* å¢å¤§åœ†è§’ */
            padding: 8px 10px; /* å¢å¤§å†…è¾¹è· */
            text-align: center;
            margin: 0 10px; /* å¢å¤§å¤–è¾¹è· */
            font-size: 36px; /* å¢å¤§å­—ä½“å¤§å°ä¸ºåŸæ¥çš„çº¦3å€ */
        }
        
        .volume-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 8px; /* å¢å¤§åœ†è§’ */
            width: 60px; /* å¢å¤§å®½åº¦ä¸ºåŸæ¥çš„çº¦3å€ */
            height: 60px; /* å¢å¤§é«˜åº¦ä¸ºåŸæ¥çš„çº¦3å€ */
            margin: 0 10px; /* å¢å¤§å¤–è¾¹è· */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px; /* å¢å¤§å­—ä½“å¤§å°ä¸ºåŸæ¥çš„çº¦3å€ */
            transition: background 0.2s;
        }
        
        .volume-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .volume-icon {
            color: white;
            font-size: 36px; /* å¢å¤§å­—ä½“å¤§å°ä¸ºåŸæ¥çš„çº¦3å€ */
            width: 40px; /* å¢å¤§å®½åº¦ */
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton">å¼€å§‹éº¦å…‹é£</button>
        <input type="file" id="audioFile" accept="audio/*">
    </div>
    <div id="statusInfo"></div>
    <div id="songTitle"></div>
    
    <!-- æ›¿æ¢éŸ³é‡æ§åˆ¶å™¨ -->
    <div id="volumeControl">
        <span class="volume-icon">ğŸ”ˆ</span>
        <button class="volume-btn" id="volumeDown">-</button>
        <input type="number" id="volumeInput" min="0" max="100" value="20">
        <button class="volume-btn" id="volumeUp">+</button>
        <span class="volume-icon">ğŸ”Š</span>
    </div>
    
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const audioFile = document.getElementById('audioFile');
        const statusInfo = document.getElementById('statusInfo');
        const songTitle = document.getElementById('songTitle');
        
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let animationId;
        let gainNode; // ç”¨äºæ§åˆ¶éŸ³é‡

        // æ·»åŠ çš„æ–°å˜é‡
        let currentMusicFile = '';
        let isAutoPlayEnabled = true; // é»˜è®¤å¼€å¯è‡ªåŠ¨æ’­æ”¾
        let audioElement = null;
        let songTitleSize = 30; // åŸºç¡€å­—ä½“å¤§å°
        let peakValue = 0; // éŸ³é¢‘å³°å€¼

        // é‡è¯•é€»è¾‘ç›¸å…³å˜é‡
        let fetchMusicRetryCount = 0;
        const MAX_MUSIC_LOAD_RETRIES = 3;

        const particles = []; // å­˜æ”¾ç²’å­å¯¹è±¡çš„æ•°ç»„
        const MAX_PARTICLES = 50; // æœ€å¤§ç²’å­æ•°é‡
        const PARTICLE_LIFETIME = 100; // ç²’å­ç”Ÿå‘½å‘¨æœŸï¼ˆå¸§æ•°ï¼‰

        // è®¾ç½®canvaså¤§å°
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ä»éŸ³ä¹æ–‡ä»¶åæå–æ­Œæ›²æ ‡é¢˜ï¼ˆå»é™¤æ­Œæ‰‹ä¿¡æ¯ï¼‰
        function extractSongTitle(filename) {
            // ç§»é™¤æ–‡ä»¶æ‰©å±•å
            let name = filename.replace(/\.(mp3|flac|wav|ogg)$/i, '');
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ "æ­Œæ‰‹ - æ ‡é¢˜" æ ¼å¼
            if (name.includes(' - ')) {
                // å–åˆ†éš”ç¬¦åé¢çš„éƒ¨åˆ†ä½œä¸ºæ ‡é¢˜
                return name.split(' - ').slice(1).join(' - ');
            }
            
            return name; // å¦‚æœæ²¡æœ‰åˆ†éš”ç¬¦ï¼Œè¿”å›æ•´ä¸ªåç§°
        }
        
        // æ”¹è¿›cleanPlaylistNameå‡½æ•°ï¼Œä¿®å¤æ­Œå•åç§°å¤„ç†é—®é¢˜
        function cleanPlaylistName(playlistName) {
            if (!playlistName) return null;
            let name = String(playlistName).trim(); //ç¡®ä¿æ˜¯å­—ç¬¦ä¸²
            
            // è®°å½•åŸå§‹è¾“å…¥ï¼Œå¸®åŠ©è°ƒè¯•
            console.log(`å¤„ç†æ­Œå•å: "${name}"`);
            
            // 1. å»å¤´ï¼šç§»é™¤å¼€å¤´çš„ã€
            if (name.startsWith('ã€')) {
                name = name.substring(1);
            }
            
            // 2. ä½¿ç”¨å­—ç¬¦ä¸²æ›¿æ¢è€Œä¸æ˜¯æˆªå–ç‰¹å®šé•¿åº¦
            // å¤„ç†å„ç§å¯èƒ½çš„åç¼€å˜ä½“
            const suffixes = [
                'ã€æ¸è¿›å­¦ä¹ æ—¶é•¿æ¿€åŠ±æ­Œå•',
                'ã€æ¸è¿›å­¦ä¹ æ—¶é•¿æ¿€æ­Œå•',
                'æ¸è¿›å­¦ä¹ æ—¶é•¿æ¿€åŠ±æ­Œå•',
                'æ¸è¿›å­¦ä¹ æ—¶é•¿æ¿€æ­Œå•',
                'ã€'
            ];
            
            for (const suffix of suffixes) {
                if (name.endsWith(suffix)) {
                    name = name.substring(0, name.length - suffix.length);
                    console.log(`ç§»é™¤åç¼€"${suffix}"ï¼Œç»“æœ: "${name}"`);
                    break;
                }
            }
            
            // ç¡®ä¿ç»“æœæ˜¯å¹²å‡€çš„
            const result = name.trim();
            console.log(`æœ€ç»ˆæ¸…ç†ç»“æœ: "${result}"`);
            return result;
        }
        
        // æ›´æ–°æ­Œæ›²æ ‡é¢˜æ˜¾ç¤º - è¶…å¼ºå…‰æ™•ç‰ˆæœ¬
        function updateSongTitleDisplay(intensity) {
            if (!currentMusicFile) return;
            
            const title = extractSongTitle(currentMusicFile);
            songTitle.textContent = title;
            
            // æ›´å¤§çš„å­—ä½“å¤§å°å˜åŒ–èŒƒå›´
            const size = songTitleSize + (intensity * 60); // æå¤§çš„å˜åŒ–èŒƒå›´
            songTitle.style.fontSize = `${size}px`;
            
            // è¶…å¼ºå…‰æ™•æ•ˆæœ - è‡³å°‘å½“å‰çš„3å€
            const glowSize = 40 + (intensity * 100); // æå¤§çš„å…‰æ™•åŸºç¡€å€¼å’Œå˜åŒ–èŒƒå›´
            const glowIntensity = Math.min(1, 0.5 + intensity * 0.5);
            
            // ä½¿ç”¨æ ¸å¿ƒé¢œè‰²ä½œä¸ºå‘å…‰æ•ˆæœï¼Œä½†å¢åŠ å¼ºåº¦
            const r = coreColorR || 100;
            const g = coreColorG || 200;
            const b = coreColorB || 255;
            
            // å¤šå±‚æ¬¡çš„æå¼ºå…‰æ™•æ•ˆæœ
            songTitle.style.textShadow = `
                0 0 ${glowSize*0.2}px rgba(255, 255, 255, 1),
                0 0 ${glowSize*0.4}px rgba(255, 255, 255, ${glowIntensity}),
                0 0 ${glowSize*0.6}px rgba(${r}, ${g}, ${b}, ${glowIntensity}),
                0 0 ${glowSize*0.8}px rgba(${r}, ${g}, ${b}, ${glowIntensity*0.9}),
                0 0 ${glowSize}px rgba(${r}, ${g}, ${b}, ${glowIntensity*0.8}),
                0 0 ${glowSize*1.5}px rgba(${r}, ${g}, ${b}, ${glowIntensity*0.7}),
                0 0 ${glowSize*2}px rgba(${r}, ${g}, ${b}, ${glowIntensity*0.6}),
                0 0 ${glowSize*3}px rgba(${r}, ${g}, ${b}, ${glowIntensity*0.5})
            `;
            
            // ä¿æŒèƒŒæ™¯é€æ˜
            songTitle.style.backgroundColor = 'transparent';
            songTitle.style.boxShadow = 'none';
            
            // è°ƒæ•´æ–‡æœ¬ä¸é€æ˜åº¦
            songTitle.style.opacity = 0.8 + (intensity * 0.2);
            
            // éšç€å¼ºåº¦è°ƒæ•´å­—é—´è·ï¼Œå¢åŠ åŠ¨æ€æ•ˆæœ
            songTitle.style.letterSpacing = `${2 + intensity * 4}px`;
            
            // éšç€å¼ºåº¦è½»å¾®ç¼©æ”¾ï¼Œå¢åŠ è„‰åŠ¨æ•ˆæœ
            const scale = 1 + intensity * 0.2;
            songTitle.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        
        // æ›¿æ¢éŸ³é‡æ§åˆ¶å™¨åŠŸèƒ½
        const volumeInput = document.getElementById('volumeInput');
        const volumeUp = document.getElementById('volumeUp');
        const volumeDown = document.getElementById('volumeDown');

        // è®¾ç½®åˆå§‹éŸ³é‡
        volumeInput.value = 50; // é»˜è®¤éŸ³é‡50%

        // æ›´æ–°éŸ³é‡çš„å‡½æ•°
        function updateVolume(value) {
            // ç¡®ä¿å€¼åœ¨0-100ä¹‹é—´
            value = Math.max(0, Math.min(100, value));
            volumeInput.value = value;
            
            // å¦‚æœgainNodeå·²åˆå§‹åŒ–ï¼Œåˆ™è®¾ç½®éŸ³é‡
            if (gainNode) {
                gainNode.gain.value = value / 100;
            }
        }

        // ç›‘å¬è¾“å…¥æ¡†å˜åŒ–
        volumeInput.addEventListener('change', function() {
            updateVolume(parseInt(this.value) || 0);
        });

        // å¢åŠ éŸ³é‡æŒ‰é’®
        volumeUp.addEventListener('click', function() {
            const currentVolume = parseInt(volumeInput.value) || 0;
            updateVolume(currentVolume + 10); // å¢åŠ 10%
        });

        // å‡å°‘éŸ³é‡æŒ‰é’®
        volumeDown.addEventListener('click', function() {
            const currentVolume = parseInt(volumeInput.value) || 0;
            updateVolume(currentVolume - 10); // å‡å°‘10%
        });

        // åˆå§‹åŒ–éŸ³é¢‘åˆ†æå™¨æ—¶è®¾ç½®é»˜è®¤éŸ³é‡ä¸è¾“å…¥æ¡†ä¸€è‡´
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.75;
            
            gainNode = audioContext.createGain();
            gainNode.gain.value = parseInt(volumeInput.value) / 100; // ä½¿ç”¨è¾“å…¥æ¡†çš„å€¼

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            gainNode.connect(analyser);
            analyser.connect(audioContext.destination);
        }
        
        // ä»éº¦å…‹é£è·å–éŸ³é¢‘
        startButton.addEventListener('click', async () => {
            if (!audioContext) initAudio();
            // ç¡®ä¿ audioContext å’Œ gainNode å·²åˆå§‹åŒ–
            if (!gainNode && audioContext) { // å¦‚æœ gainNode æœªåœ¨ initAudio ä¸­æ­£ç¡®åˆ›å»ºï¼ˆç†è®ºä¸Šä¸åº”å‘ç”Ÿï¼‰
                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.4;
                gainNode.connect(analyser);
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if (source) { // å¦‚æœå·²æœ‰sourceï¼Œå…ˆæ–­å¼€
                    source.disconnect();
                }
                source = audioContext.createMediaStreamSource(stream);
                source.connect(gainNode); // éŸ³é¢‘æºè¿æ¥åˆ° GainNode
                
                if (!animationId) {
                    draw();
                }
            } catch (err) {
                console.error('è·å–éº¦å…‹é£å¤±è´¥:', err);
            }
        });
        
        // ä»æ–‡ä»¶è·å–éŸ³é¢‘
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!audioContext) initAudio();
            
            const reader = new FileReader();
            reader.onload = (e) => {
                audioContext.decodeAudioData(e.target.result, (buffer) => {
                    if (source) {
                        source.disconnect();
                    }
                    // ç¡®ä¿ audioContext å’Œ gainNode å·²åˆå§‹åŒ–
                    if (!gainNode && audioContext) { // å¦‚æœ gainNode æœªåœ¨ initAudio ä¸­æ­£ç¡®åˆ›å»º
                        gainNode = audioContext.createGain();
                        gainNode.gain.value = 0.4;
                        gainNode.connect(analyser);
                    }
                    
                    source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(gainNode); // éŸ³é¢‘æºè¿æ¥åˆ° GainNode
                    source.start(0);
                    
                    // æ›´æ–°å½“å‰æ–‡ä»¶åå¹¶æ˜¾ç¤ºæ ‡é¢˜
                    currentMusicFile = file.name;
                    updateSongTitleDisplay(0.5); // åˆå§‹ä¸­ç­‰å¼ºåº¦
                    
                    if (!animationId) {
                        draw();
                    }
                });
            };
            reader.readAsArrayBuffer(file);
        });
        
        // æ·»åŠ ä¸€ä¸ªæ–°å‡½æ•°ç”¨äºä»CSVè·å–çº§åˆ«ä¿¡æ¯
        async function getLevelFromCSV(musicName) {
            try {
                // è·å–CSVæ–‡ä»¶
                const response = await fetch('./WallpaperMusicMatcher.csv');
                if (!response.ok) {
                    // throw new Error(`æ— æ³•åŠ è½½CSVæ–‡ä»¶: ${response.status}`); // æ”¹ä¸ºè¿”å›null
                    console.warn(`æ— æ³•åŠ è½½CSVæ–‡ä»¶: ${response.status}, musicName: ${musicName}`);
                    return null;
                }
                
                const csvText = await response.text();
                
                // ç§»é™¤BOM (Byte Order Mark)
                let cleanedCsvText = csvText;
                if (cleanedCsvText.charCodeAt(0) === 0xFEFF) {
                    cleanedCsvText = cleanedCsvText.substring(1);
                }
                
                const lines = cleanedCsvText.split('\n');
                
                // æŸ¥æ‰¾åŒ¹é…çš„æ­Œæ›²
                for (let i = 1; i < lines.length; i++) { // ä»ç¬¬äºŒè¡Œå¼€å§‹ï¼ˆè·³è¿‡æ ‡é¢˜è¡Œï¼‰
                    const columns = lines[i].split(',');
                    if (columns.length >= 2) {
                        const songNameInCsv = columns[1].trim();
                        if (songNameInCsv === musicName) {
                            // æ‰¾åˆ°åŒ¹é…çš„æ­Œæ›²ï¼Œæå–å¹¶æ¸…ç†æ­Œå•å
                            let playlistName = columns[0].trim();
                            return cleanPlaylistName(playlistName); // ä½¿ç”¨æ¸…ç†å‡½æ•°
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…é¡¹ï¼Œè¿”å›null
                console.log(`åœ¨CSVä¸­æœªæ‰¾åˆ°æ­Œæ›² "${musicName}" çš„çº§åˆ«ä¿¡æ¯ã€‚`);
                return null;
            } catch (error) {
                console.error(`ä»CSVè·å–çº§åˆ«ä¿¡æ¯ '${musicName}' å¤±è´¥:`, error);
                return null; // å‡ºé”™æ—¶è¿”å›null
            }
        }

        // ä¿®æ”¹loadColorFromConfigå‡½æ•°ï¼Œä»CSVè·å–çº§åˆ«ï¼Œå¹¶æ¥å—å¯é€‰å‚æ•°
        async function loadColorFromConfig(providedLevel = null) {
            try {
                let currentLevel = providedLevel;

                if (!currentLevel) {
                    // å¦‚æœæ²¡æœ‰æä¾›çº§åˆ«ï¼Œå¹¶ä¸”æ²¡æœ‰å½“å‰éŸ³ä¹æ–‡ä»¶ï¼Œåˆ™ä¸è¿›è¡Œæ“ä½œ
                    if (!currentMusicFile) {
                        console.log("loadColorFromConfig: æ²¡æœ‰å½“å‰éŸ³ä¹æ–‡ä»¶ï¼Œä¸åŠ è½½é¢œè‰²ã€‚");
                        return;
                    }
                    
                    // å°è¯•ä»CSVè·å–å½“å‰çº§åˆ«
                    currentLevel = await getLevelFromCSV(currentMusicFile);

                    if (!currentLevel) {
                        // å¦‚æœCSVä¸­æ²¡æœ‰ï¼Œå°è¯•ä» floating_button_data.json çš„ current_level è·å–
                        console.log(`loadColorFromConfig: CSVæœªæ‰¾åˆ° ${currentMusicFile} çš„çº§åˆ«, å°è¯•ä»JSONè·å–.`);
                        try {
                            const response = await fetch(`./floating_button_data.json?t=${Date.now()}`);
                            if (response.ok) {
                                const data = await response.json();
                                // ç¡®ä¿JSONä¸­çš„éŸ³ä¹ä¸å½“å‰éŸ³ä¹åŒ¹é…
                                if (data.current_music === currentMusicFile && data.current_level) {
                                   currentLevel = cleanPlaylistName(data.current_level);
                                   console.log(`loadColorFromConfig: ä»JSONçš„current_levelè·å–åˆ°çº§åˆ«: ${currentLevel}`);
                                } else {
                                    console.log(`loadColorFromConfig: JSONä¸­çš„éŸ³ä¹ (${data.current_music}) ä¸å½“å‰éŸ³ä¹ (${currentMusicFile}) ä¸åŒ¹é…æˆ–æ— current_level.`);
                                }
                            } else {
                                console.warn(`loadColorFromConfig: æ— æ³•åŠ è½½ floating_button_data.json ä»¥è·å–å¤‡ç”¨çº§åˆ«.`);
                            }
                        } catch (e) { 
                            console.warn("loadColorFromConfig: è·å–JSONä»¥è·å–å¤‡ç”¨çº§åˆ«æ—¶å‡ºé”™:", e); 
                        }
                    }
                }
                
                if (!currentLevel) {
                    console.warn(`loadColorFromConfig: æœ€ç»ˆæ— æ³•ç¡®å®šæ­Œæ›² "${currentMusicFile || 'æœªçŸ¥æ­Œæ›²'}" çš„çº§åˆ«ï¼Œæ— æ³•åŠ è½½ç‰¹å®šé¢œè‰²é…ç½®ã€‚`);
                    // åœ¨è¿™é‡Œå¯ä»¥è€ƒè™‘é‡ç½®ä¸ºéå¸¸é€šç”¨çš„é»˜è®¤é¢œè‰²æ–¹æ¡ˆï¼Œæˆ–è€…ä»€ä¹ˆéƒ½ä¸åš
                    // setColorTheme(40, 140, 255); // ä¾‹å¦‚ï¼Œé‡ç½®ä¸ºé»˜è®¤è“è‰²ç³»
                    return;
                }

                console.log(`loadColorFromConfig: å½“å‰é˜¶æ®µç¡®å®šä¸º: ${currentLevel}`);
                
                // ç„¶åä»config.jsonåŠ è½½é¢œè‰²é…ç½®
                const configResponse = await fetch('config.json');
                if (!configResponse.ok) {
                    throw new Error('æ— æ³•åŠ è½½é…ç½®æ–‡ä»¶ config.json');
                }
                
                const config = await configResponse.json();
                
                // æŸ¥æ‰¾å½“å‰é˜¶æ®µçš„é¢œè‰²
                const levelConfig = config.levels.find(level => level.name === currentLevel);
                
                if (levelConfig && levelConfig.color) {
                    // è§£æRGBAé¢œè‰²
                    const rgbaMatch = levelConfig.color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
                    
                    if (rgbaMatch) {
                        // æ›´æ–°æ ¸å¿ƒé¢œè‰²
                        coreColorR = parseInt(rgbaMatch[1]);
                        coreColorG = parseInt(rgbaMatch[2]);
                        coreColorB = parseInt(rgbaMatch[3]);
                        
                        // é‡æ–°ç”Ÿæˆé¢œè‰²æ–¹æ¡ˆ
                        updateColorVariables();
                        
                        console.log(`å·²ä»é…ç½®åŠ è½½é¢œè‰²: R=${coreColorR}, G=${coreColorG}, B=${coreColorB} (çº§åˆ«: ${currentLevel})`);
                    } else {
                         console.warn(`é˜¶æ®µ"${currentLevel}"çš„é¢œè‰²æ ¼å¼æ— æ³•è§£æ: ${levelConfig.color}`);
                    }
                } else {
                    console.warn(`æœªæ‰¾åˆ°é˜¶æ®µ"${currentLevel}"çš„é¢œè‰²é…ç½®ï¼Œå°†ä½¿ç”¨å½“å‰çš„æˆ–é»˜è®¤çš„é¢œè‰²ã€‚`);
                }
            } catch (error) {
                console.error('åŠ è½½é¢œè‰²é…ç½®å¤±è´¥:', error);
            }
        }

        // ä¿®æ”¹fetchCurrentMusicå‡½æ•°ï¼Œæ·»åŠ æ›´ä¸¥æ ¼çš„é”™è¯¯å¤„ç†å’Œå†·å´æœŸ
        async function fetchCurrentMusic() {
            if (!isAutoPlayEnabled) return;
            
            // é˜²æ­¢é‡å¤è¯·æ±‚ï¼šå¦‚æœä¸Šæ¬¡è¯·æ±‚æ—¶é—´å¤ªè¿‘ï¼Œåˆ™è·³è¿‡æœ¬æ¬¡è¯·æ±‚
            if (window.lastFetchTime && (Date.now() - window.lastFetchTime < 3000)) {
                // console.log("è¯·æ±‚é—´éš”å¤ªçŸ­ï¼Œè·³è¿‡æœ¬æ¬¡è¯·æ±‚");
                return;
            }
            window.lastFetchTime = Date.now();
            
            try {
                // æ·»åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
                const timestamp = Date.now();
                const response = await fetch(`./floating_button_data.json?t=${timestamp}`);
                
                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯! çŠ¶æ€: ${response.status} (æ— æ³•åŠ è½½ floating_button_data.json)`);
                }
                
                const data = await response.json();
                const musicName = data.current_music;
                const levelFromJsonRaw = data.current_level; // ä»JSONè·å–åŸå§‹current_level
                
                // æ£€æŸ¥æ˜¯å¦ä¸æœ€è¿‘å¤±è´¥çš„éŸ³ä¹æ–‡ä»¶ç›¸åŒï¼Œå¦‚æœæ˜¯ä¸”æœ€è¿‘å¤±è´¥æ¬¡æ•°è¿‡å¤šï¼Œåˆ™è·³è¿‡
                if (window.recentFailedMusic === musicName && window.recentFailedCount >= MAX_MUSIC_LOAD_RETRIES) {
                    console.log(`è·³è¿‡æœ€è¿‘å¤šæ¬¡å¤±è´¥çš„éŸ³ä¹: ${musicName}ï¼Œé˜²æ­¢æ— é™é‡è¯•`);
                    return;
                }
                
                if (musicName && musicName !== currentMusicFile) {
                    console.log(`æ£€æµ‹åˆ°æ–°éŸ³ä¹: ${musicName} (ä¹‹å‰: ${currentMusicFile || 'æ— '})`);
                    // éŸ³ä¹å·²æ›´æ”¹ï¼Œå…ˆç»ˆæ­¢å½“å‰æ’­æ”¾çš„éŸ³ä¹
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = ''; // æ¸…é™¤æºï¼Œé˜²æ­¢æ—§éŸ³é¢‘å¹²æ‰°
                    }
                    if (source) {
                        try { source.disconnect(); } catch(e) {}
                    }
                    
                    let levelFolderName = await getLevelFromCSV(musicName);
                    
                    if (!levelFolderName && levelFromJsonRaw) {
                        console.log(`æ— æ³•ä»CSVè·å– "${musicName}" çš„çº§åˆ«ï¼Œå°è¯•ä½¿ç”¨ floating_button_data.json ä¸­çš„ current_level: "${levelFromJsonRaw}"`);
                        levelFolderName = cleanPlaylistName(levelFromJsonRaw);
                        if (levelFolderName) {
                            console.log(`ä½¿ç”¨æ¥è‡ªJSONçš„æ¸…ç†åçº§åˆ«: "${levelFolderName}"`);
                        } else {
                            console.warn(`æ¸…ç†æ¥è‡ªJSONçš„çº§åˆ« "${levelFromJsonRaw}" åç»“æœä¸ºç©ºã€‚`);
                        }
                    }

                    if (!levelFolderName) {
                        console.error(`æ— æ³•ä¸ºæ­Œæ›² "${musicName}" ç¡®å®šæœ‰æ•ˆçš„çº§åˆ«ä¿¡æ¯ (å°è¯•äº†CSVå’ŒJSON)ã€‚å°†ä¸ä¼šå°è¯•æ’­æ”¾æ­¤æ­Œæ›²ã€‚`);
                        // è®°å½•è¿™ä¸ªå¤±è´¥ï¼Œé˜²æ­¢é‡å¤å°è¯•
                        window.recentFailedMusic = musicName;
                        window.recentFailedCount = MAX_MUSIC_LOAD_RETRIES + 1; // ç›´æ¥è®¾ä¸ºè¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°
                        return; 
                    }
                    
                    console.log(`æœ€ç»ˆç¡®å®šæ­Œæ›² "${musicName}" çš„çº§åˆ«ä¸º: "${levelFolderName}"`);
                    
                    // æ„å»ºéŸ³ä¹æ–‡ä»¶è·¯å¾„
                    const musicPath = `./music_library/${levelFolderName}/${musicName}`;
                    
                    // è°ƒç”¨ loadAndPlayMusicï¼Œå®ƒå°†åœ¨æˆåŠŸæ—¶æ›´æ–° currentMusicFile, songTitle, colors
                    loadAndPlayMusic(musicPath, musicName, levelFolderName);
                    
                    if(window.location.href.includes('-test')) {
                        statusInfo.style.display = 'block';
                        statusInfo.textContent = `å°è¯•æ’­æ”¾: ${musicName} (æ¥è‡ªçº§åˆ«: ${levelFolderName})`;
                    }
                }
            } catch (error) {
                console.error('è·å–æˆ–å¤„ç†éŸ³ä¹ä¿¡æ¯å¤±è´¥ (fetchCurrentMusic try/catch):', error);
                // æ·»åŠ æš‚åœæ—¶é—´ï¼Œé¿å…å¿«é€Ÿè¿ç»­è¯·æ±‚
                await new Promise(resolve => setTimeout(resolve, 5000));
                if(window.location.href.includes('-test')) {
                    statusInfo.textContent = `è·å–éŸ³ä¹ä¿¡æ¯å¤±è´¥: ${error.message}`;
                    statusInfo.style.display = 'block';
                    setTimeout(() => { statusInfo.style.display = 'none'; }, 10000);
                }
            }
        }
        
        // ä¿®æ”¹loadAndPlayMusicå‡½æ•°ï¼ŒåŠ å¼ºé”™è¯¯å¤„ç†å’Œé˜²æ­¢æ— é™é‡è¯•
        function loadAndPlayMusic(musicPath, newMusicName, levelNameForStatus) {
            if (!audioContext) initAudio();
            
            if (source) {
                try { source.disconnect(); } catch (e) {}
            }
            
            if (audioElement) {
                audioElement.pause();
                audioElement.removeAttribute('src');
                audioElement.load();
            }
            
            // è®°å½•å½“å‰å°è¯•çš„éŸ³ä¹ï¼Œç”¨äºè·Ÿè¸ªå¤±è´¥
            window.recentFailedMusic = newMusicName;
            
            audioElement = new Audio();
            audioElement.crossOrigin = "anonymous";
            
            const handleErrorAndRetry = (errorType, errorMessage) => {
                console.error(`${errorType}: ${newMusicName} (è·¯å¾„: ${musicPath}). ${errorMessage}`);
                
                // æ›´æ–°å¤±è´¥è®¡æ•°
                window.recentFailedCount = (window.recentFailedCount || 0) + 1;
                console.log(`å½“å‰å¤±è´¥è®¡æ•°: ${window.recentFailedCount}/${MAX_MUSIC_LOAD_RETRIES}`);

                if (window.recentFailedCount <= MAX_MUSIC_LOAD_RETRIES) {
                    console.log(`éŸ³ä¹å¤„ç†å¤±è´¥ï¼Œå»¶è¿Ÿé‡è¯• (${window.recentFailedCount}/${MAX_MUSIC_LOAD_RETRIES})...`);
                    if(window.location.href.includes('-test')) {
                        statusInfo.textContent = `${errorType}: ${newMusicName}. é‡è¯• ${window.recentFailedCount}/${MAX_MUSIC_LOAD_RETRIES}...`;
                        statusInfo.style.display = 'block';
                    }
                    
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = '';
                    }
                    
                    // å¢åŠ æ›´é•¿çš„å»¶è¿Ÿï¼Œé¿å…é¢‘ç¹é‡è¯•
                    setTimeout(() => {
                        // æ£€æŸ¥æ˜¯å¦ä¸æœ€è¿‘å¤±è´¥çš„éŸ³ä¹ç›¸åŒ
                        if (window.recentFailedMusic === newMusicName) {
                            console.log(`å»¶è¿Ÿåå°è¯•é‡è¯•æ’­æ”¾: ${newMusicName}`);
                            fetchCurrentMusic(); // é‡æ–°ä»è·å–jsonå¼€å§‹
                        }
                    }, 5000 + window.recentFailedCount * 2000); // æ›´é•¿çš„æŒ‡æ•°çº§å»¶è¿Ÿ
                } else {
                    console.error(`éŸ³ä¹ "${newMusicName}" è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° (${MAX_MUSIC_LOAD_RETRIES})ï¼Œæ”¾å¼ƒæ’­æ”¾ã€‚`);
                    if(window.location.href.includes('-test')) {
                        statusInfo.textContent = `æ”¾å¼ƒæ’­æ”¾ ${newMusicName} (å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°).`;
                        statusInfo.style.display = 'block';
                        setTimeout(() => { statusInfo.style.display = 'none'; }, 15000);
                    }
                    
                    // æ”¾å¼ƒåï¼Œæ¸…é™¤å½“å‰éŸ³ä¹çŠ¶æ€
                    if (currentMusicFile === newMusicName) {
                        currentMusicFile = '';
                        songTitle.textContent = '';
                    }
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    // ä¸è¦é‡ç½®å¤±è´¥è®¡æ•°å™¨ï¼Œä¿æŒè®°å¿†ä»¥é¿å…æ— é™é‡è¯•
                    // window.recentFailedCount = 0;
                }
            };

            audioElement.addEventListener('error', (e) => {
                let errorDetail = "æœªçŸ¥åŠ è½½é”™è¯¯";
                if (e.target && e.target.error) {
                    switch (e.target.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED: errorDetail = 'ç”¨æˆ·ä¸­æ­¢'; break;
                        case MediaError.MEDIA_ERR_NETWORK: errorDetail = 'ç½‘ç»œé”™è¯¯'; break;
                        case MediaError.MEDIA_ERR_DECODE: errorDetail = 'è§£ç é”™è¯¯'; break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorDetail = 'æºä¸æ”¯æŒ'; break;
                        default: errorDetail = `ä»£ç : ${e.target.error.code}`;
                    }
                }
                handleErrorAndRetry('éŸ³é¢‘åŠ è½½é”™è¯¯', errorDetail);
            });
            
            audioElement.src = musicPath;
            
            // æ·»åŠ ä¸€ä¸ª10ç§’è¶…æ—¶ï¼Œé˜²æ­¢åŠ è½½æ— å“åº”
            const loadTimeout = setTimeout(() => {
                console.log(`éŸ³ä¹åŠ è½½è¶…æ—¶: ${newMusicName}`);
                handleErrorAndRetry('åŠ è½½è¶…æ—¶', '10ç§’å†…æœªå“åº”');
            }, 10000);

            audioElement.addEventListener('canplaythrough', () => {
                // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
                clearTimeout(loadTimeout);
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(e => console.warn("AudioContext resume failed:", e));
                }
                
                if (source) { // ç¡®ä¿æ—§çš„sourceå·²æ–­å¼€
                     try { source.disconnect(); } catch(e){}
                }
                source = audioContext.createMediaElementSource(audioElement);
                source.connect(gainNode);
                
                const playPromise = audioElement.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log(`éŸ³ä¹ "${newMusicName}" (çº§åˆ«: "${levelNameForStatus}") æˆåŠŸå¼€å§‹æ’­æ”¾ã€‚`);
                        currentMusicFile = newMusicName; 
                        updateSongTitleDisplay(0.5); 
                        loadColorFromConfig(levelNameForStatus); // ä¼ é€’å·²çŸ¥çš„çº§åˆ«

                        if(window.location.href.includes('-test')) {
                            statusInfo.style.display = 'block';
                            statusInfo.textContent = `æ­£åœ¨æ’­æ”¾: ${newMusicName} (çº§åˆ«: ${levelNameForStatus})`;
                            setTimeout(() => { statusInfo.style.display = 'none'; }, 30000);
                        }
                        
                        // é‡ç½®å¤±è´¥è®¡æ•°å™¨ï¼Œå› ä¸ºæˆåŠŸæ’­æ”¾äº†
                        window.recentFailedCount = 0;
                        window.recentFailedMusic = '';
                        if (!animationId) {
                            draw();
                        }
                    }).catch(err => {
                        handleErrorAndRetry('æ’­æ”¾æ“ä½œå¤±è´¥', err.message);
                    });
                } else {
                     // å¯¹äºæ²¡æœ‰è¿”å›Promiseçš„æ—§æµè§ˆå™¨ï¼Œæˆ‘ä»¬å‡è®¾å®ƒä¼šå°è¯•æ’­æ”¾
                     // ä½†ç°ä»£æµè§ˆå™¨éƒ½åº”è¯¥è¿”å›Promise
                     console.warn("audioElement.play() did not return a Promise. Assuming playback started.");
                     // åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ— æ³•ç¡®åˆ‡çŸ¥é“æ’­æ”¾æ˜¯å¦æˆåŠŸï¼Œä½†å¯ä»¥ä¹è§‚å¤„ç†
                        currentMusicFile = newMusicName; 
                        updateSongTitleDisplay(0.5); 
                        loadColorFromConfig(levelNameForStatus);
                        if(window.location.href.includes('-test')) {
                            statusInfo.style.display = 'block';
                            statusInfo.textContent = `æ­£åœ¨æ’­æ”¾ (æ— Promise): ${newMusicName}`;
                        }
                        // é‡ç½®å¤±è´¥è®¡æ•°å™¨ï¼Œå› ä¸ºæˆåŠŸæ’­æ”¾äº†
                        window.recentFailedCount = 0;
                        window.recentFailedMusic = '';
                        if (!animationId) draw();
                }
            });
            
            audioElement.loop = false; // é€šå¸¸èƒŒæ™¯éŸ³ä¹å¯è§†åŒ–ä¸éœ€è¦å¾ªç¯å•ä¸ªæ–‡ä»¶ï¼Œè€Œæ˜¯åˆ—è¡¨åˆ‡æ¢
        }
        
        // ç§»é™¤ tryFallbackPath å‡½æ•°ï¼Œæˆ–æ³¨é‡Šæ‰
        /*
        function tryFallbackPath(originalPath) {
            // ... (å†…å®¹å·²çœç•¥) ...
        }
        */

        function createParticle(x, y, size, color, speedMultiplier = 1) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 2 + 1) * speedMultiplier;
            return {
                x,
                y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * size + size,
                color: color || `rgba(255, 255, 255, ${Math.random() * 0.2 + 0.8})`,
                life: PARTICLE_LIFETIME,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.1
            };
        }

        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.rotation += p.rotationSpeed;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                
                // ä½¿ç”¨ä¸å‚è€ƒå›¾ä¸€è‡´çš„ä¸‰è§’å½¢é£æ ¼ï¼šä¸‰ä¸ªç‚¹ä¸‰ä¸ªçº¿ï¼Œç™½çº¿è“å…‰æ™•
                const triangleSize = p.size * 1.8; // æ›´å¤§ä¸€äº›
                const halfSize = triangleSize / 2;
                
                // ä¸‰ä¸ªç‚¹çš„ä½ç½®
                const points = [
                    {x: 0, y: -halfSize},          // é¡¶ç‚¹
                    {x: halfSize, y: halfSize},    // å³ä¸‹
                    {x: -halfSize, y: halfSize}    // å·¦ä¸‹
                ];
                
                // 1. ç»˜åˆ¶å¼ºçƒˆçš„è“è‰²å…‰æ™• (æ²¡æœ‰å¡«å……è‰²)
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = triangleSize * 1.5;
                ctx.shadowColor = rgba(colorScheme.intense, p.life / PARTICLE_LIFETIME * 0.9);
                
                // 2. ç»˜åˆ¶ç™½è‰²çº¿æ¡†
                ctx.beginPath();
                // ç»˜åˆ¶ä¸‰è§’å½¢è½®å»“ (ä¸‰æ¡çº¿)
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.closePath();
                
                // æ›´æ˜æ˜¾çš„ç™½è‰²çº¿æ¡
                ctx.strokeStyle = rgba(colorScheme.point, p.life / PARTICLE_LIFETIME * 0.95);
                ctx.lineWidth = 1.8; // ç¨å¾®ç²—ä¸€ç‚¹çš„çº¿
                ctx.stroke();
                
                // 3. åœ¨ä¸‰ä¸ªé¡¶ç‚¹ç»˜åˆ¶æ›´å¤§çš„å…‰ç‚¹
                const pointRadius = 2.5; // å¢å¤§ç«¯ç‚¹å°ºå¯¸
                ctx.shadowBlur = 8;
                ctx.shadowColor = rgba(colorScheme.mid, 0.9);
                
                for (let j = 0; j < 3; j++) {
                    // å…ˆç»˜åˆ¶å…‰æ™•
                    ctx.beginPath();
                    ctx.arc(points[j].x, points[j].y, pointRadius * 1.5, 0, Math.PI * 2);
                    const pointGlow = ctx.createRadialGradient(
                        points[j].x, points[j].y, 0,
                        points[j].x, points[j].y, pointRadius * 2.5
                    );
                    pointGlow.addColorStop(0, rgba(colorScheme.highlight, p.life / PARTICLE_LIFETIME * 0.8));
                    pointGlow.addColorStop(0.6, rgba(colorScheme.core, p.life / PARTICLE_LIFETIME * 0.4));
                    pointGlow.addColorStop(1, rgba(colorScheme.dark, 0));
                    ctx.fillStyle = pointGlow;
                    ctx.fill();
                    
                    // å†ç»˜åˆ¶ç™½è‰²æ ¸å¿ƒ
                    ctx.beginPath();
                    ctx.arc(points[j].x, points[j].y, pointRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.life / PARTICLE_LIFETIME * 0.95})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // --- æ ¸å¿ƒé¢œè‰²å®šä¹‰ä¸è¾…åŠ©é¢œè‰²ç”Ÿæˆ ---
        // é»˜è®¤æ˜¯è“è‰²ç³»ï¼Œä½†ä¼šæ ¹æ®config.jsonä¸­çš„é˜¶æ®µé¢œè‰²è¿›è¡Œæ›´æ–°
        let coreColorR = 40;  // çº¢è‰²æˆåˆ†
        let coreColorG = 140; // ç»¿è‰²æˆåˆ†
        let coreColorB = 255; // è“è‰²æˆåˆ† (æœ€å¤§å€¼)

        // æ›´å¼ºå¤§çš„é¢œè‰²å˜ä½“è®¡ç®—å‡½æ•°
        function generateColorScheme(r, g, b) {
            // ç¡®ä¿å€¼åœ¨åˆç†èŒƒå›´å†…
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            return {
                // æ ¸å¿ƒé¢œè‰²æœ¬èº«
                core: {r, g, b},
                
                // æ›´äº®çš„å˜ä½“ (å¢åŠ æ‰€æœ‰é€šé“ä»¥ä¿æŒåŸå§‹é¢œè‰²çš„ç›¸å¯¹æ¯”ä¾‹)
                bright: {
                    r: Math.min(255, r + (255 - r) * 0.7),
                    g: Math.min(255, g + (255 - g) * 0.7), 
                    b: Math.min(255, b + (255 - b) * 0.7)
                },
                
                // å‘å…‰æ•ˆæœä½¿ç”¨çš„æ·¡åŒ–å˜ä½“
                glow: {
                    r: Math.min(255, r + (255 - r) * 0.4),
                    g: Math.min(255, g + (255 - g) * 0.4),
                    b: Math.min(255, b + (255 - b) * 0.4)
                },
                
                // è¾…åŠ©é¢œè‰² (ä¸­ç­‰äº®åº¦)
                mid: {
                    r: Math.min(255, r + (255 - r) * 0.2),
                    g: Math.min(255, g + (255 - g) * 0.2),
                    b: Math.min(255, b + (255 - b) * 0.2)
                },
                
                // æ·±è‰²å˜ä½“ (ç”¨äºæ¸å˜ç»ˆç‚¹ï¼Œé™ä½äº®åº¦ä½†ä¿æŒè‰²ç›¸)
                dark: {
                    r: Math.floor(r * 0.6),
                    g: Math.floor(g * 0.6),
                    b: Math.floor(b * 0.6)
                },
                
                // æ›´æ·±çš„å˜ä½“
                darker: {
                    r: Math.floor(r * 0.3),
                    g: Math.floor(g * 0.3),
                    b: Math.floor(b * 0.3)
                },
                
                // çº¿æ¡é¢œè‰² (çº¯ç™½è‰²ï¼Œä½†ä¿ç•™å¾®å¼±çš„æ ¸å¿ƒè‰²å…‰æ™•)
                line: {
                    r: Math.min(255, r + (255 - r) * 0.95),
                    g: Math.min(255, g + (255 - g) * 0.95),
                    b: Math.min(255, b + (255 - b) * 0.95)
                },
                
                // ç‚¹çš„é¢œè‰² (çº¯ç™½è‰²ï¼Œä½œä¸ºé«˜å…‰)
                point: {
                    r: 255,
                    g: 255,
                    b: 255
                },
                
                // ç‰¹æ®Šå˜ä½“
                // æ›´é€æ˜çš„æ ¸å¿ƒè‰²
                soft: {
                    r: Math.min(255, r + (255 - r) * 0.1),
                    g: Math.min(255, g + (255 - g) * 0.1),
                    b: Math.min(255, b + (255 - b) * 0.1)
                },
                
                // æ›´å¼ºçƒˆçš„æ ¸å¿ƒè‰²
                intense: {
                    r: Math.max(0, r - r * 0.1),
                    g: Math.max(0, g - g * 0.1),
                    b: Math.max(0, b - b * 0.1)
                },
                
                // é«˜äº®å˜ä½“
                highlight: {
                    r: Math.min(255, r + (255 - r) * 0.5),
                    g: Math.min(255, g + (255 - g) * 0.5),
                    b: Math.min(255, b + (255 - b) * 0.5)
                }
            };
        }

        // ç”Ÿæˆå½“å‰çš„é¢œè‰²æ–¹æ¡ˆ
        let colorScheme = generateColorScheme(coreColorR, coreColorG, coreColorB);

        // æ›´æ–°æ‰€æœ‰é¢œè‰²å˜é‡
        function updateColorVariables() {
            colorScheme = generateColorScheme(coreColorR, coreColorG, coreColorB);
        }

        // æ–¹ä¾¿ç”Ÿæˆrgbaå­—ç¬¦ä¸²çš„å‡½æ•°
        function rgba(color, alpha) {
            return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
        }

        // å…è®¸é€šè¿‡å‚æ•°æ›´æ”¹é¢œè‰²ä¸»é¢˜
        function setColorTheme(r, g, b) {
            coreColorR = r;
            coreColorG = g;
            coreColorB = b;
            updateColorVariables();
        }

        // ç»˜åˆ¶å¯è§†åŒ–æ•ˆæœ
        function draw() {
            animationId = requestAnimationFrame(draw);
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // è®¡ç®—å½“å‰éŸ³é¢‘å¼ºåº¦ï¼Œå¹¶ç«‹å³æ›´æ–°æ ‡é¢˜æ•ˆæœ
            const sum = dataArray.reduce((acc, val) => acc + val, 0);
            const avg = sum / dataArray.length;
            const normalizedIntensity = Math.min(1, avg / 120); // å½’ä¸€åŒ–åˆ°0-1èŒƒå›´ï¼Œé™ä½é˜ˆå€¼ä½¿æ•ˆæœæ›´æ˜æ˜¾
            
            // æ¯å¸§å®æ—¶æ›´æ–°æ­Œæ›²æ ‡é¢˜æ•ˆæœï¼Œç¡®ä¿ä¸éŸ³ä¹åŒæ­¥
            if (currentMusicFile) {
                updateSongTitleDisplay(normalizedIntensity);
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = Math.min(canvas.width, canvas.height) / 3.0; // å¢å¤§åŸºç¡€åŠå¾„
            
            // å®šä¹‰é¢‘ç‡èŒƒå›´å’Œé¢‘æ®µæ•°é‡
            const targetStartFreq = 20; // Hz
            const targetEndFreq = 1000; // Hz
            const numVisualBars = 80; // å›ºå®šçš„é¢‘æ®µæ•°é‡

            const nyquist = audioContext.sampleRate / 2;
            const startIndex = Math.max(0, Math.floor(targetStartFreq / nyquist * analyser.frequencyBinCount));
            const endIndex = Math.min(analyser.frequencyBinCount - 1, Math.ceil(targetEndFreq / nyquist * analyser.frequencyBinCount));
            const selectedDataLength = endIndex - startIndex + 1;

            // è®¡ç®—æ•´ä½“éŸ³é¢‘å¼ºåº¦ï¼Œç”¨äºå…‰æ™•æ•ˆæœ
            const overallBrightness = dataArray.reduce((sum, val) => sum + val, 0) / (dataArray.length * 255);
            
            // --- è®¡ç®—é¢‘è°±ä¿¡æ¯å¹¶å­˜å‚¨ç‚¹åæ ‡ ---
            let peakValue = 0;
            // ä¸»è¦é«˜åº¦æ§åˆ¶å‚æ•°
            const maxBarHeightRatio = 1; 
            const heightExponent = 8.0;   
            
            // ä½éŸ³é‡æ•æ„Ÿè·³åŠ¨æ§åˆ¶å‚æ•° - æ›´å¹³è¡¡çš„è®¾ç½®
            const milletGrainHeight = 0.8;          
            const flickerActivationThreshold = 0.002; 
            const flickerSaturationThreshold = 0.12;  
            const flickerIntensityExponent = 0.4;     
            const microVariationIntensity = 0.15;     
            
            const pointsA = []; 
            const pointsB = []; 

            for (let i = 0; i < numVisualBars; i++) {
                // ä»é€‰å®šçš„é¢‘ç‡æ•°æ®èŒƒå›´ä¸­é‡‡æ ·
                let valueSum = 0;
                const samplesPerBar = Math.max(1, Math.floor(selectedDataLength / numVisualBars));
                const barDataStartIndex = startIndex + Math.floor(i * (selectedDataLength / numVisualBars));
                
                for (let j = 0; j < samplesPerBar; j++) {
                    const dataIdx = Math.min(endIndex, barDataStartIndex + j);
                    valueSum += dataArray[dataIdx] || 0;
                }
                let value = samplesPerBar > 0 ? valueSum / samplesPerBar : 0;

                if (value > peakValue) peakValue = value;

                const angle = (i / numVisualBars) * Math.PI * 2 - Math.PI / 2; 
                
                const normalizedValue = value / 255; 
                const nonLinearValue = Math.pow(normalizedValue, heightExponent); 
                                
                // è®¡ç®—ä¸»è¦é«˜åº¦
                const mainBarHeight = nonLinearValue * (baseRadius * maxBarHeightRatio); 

                // è®¡ç®—æ•æ„Ÿçš„ä½éŸ³é‡è·³åŠ¨é«˜åº¦
                let dynamicFlickerHeight = 0;
                if (normalizedValue > flickerActivationThreshold) {
                    const intensityRatio = Math.min(1, (normalizedValue - flickerActivationThreshold) / 
                                               (flickerSaturationThreshold - flickerActivationThreshold));
                    
                    dynamicFlickerHeight = Math.pow(intensityRatio, flickerIntensityExponent) * milletGrainHeight;
                    const microVariation = normalizedValue * microVariationIntensity * (Math.random() - 0.5);
                    dynamicFlickerHeight = Math.max(0, dynamicFlickerHeight + microVariation);
                }

                // ç»“åˆä¸¤ç§é«˜åº¦
                let barHeight = Math.max(mainBarHeight, dynamicFlickerHeight);
                barHeight = Math.max(0.05, barHeight); 

                const radiusA = baseRadius + barHeight;
                const xA = centerX + radiusA * Math.cos(angle);
                const yA = centerY + radiusA * Math.sin(angle);
                pointsA.push({ x: xA, y: yA, val: nonLinearValue, originalNormalizedValue: normalizedValue });

                const radiusB = baseRadius - barHeight;
                const xB = centerX + radiusB * Math.cos(angle);
                const yB = centerY + radiusB * Math.sin(angle);
                pointsB.push({ x: xB, y: yB, val: nonLinearValue, originalNormalizedValue: normalizedValue });
            }
            
            // --- ç»˜åˆ¶å¤–å›´å…‰æ™• ---
            const spectrumOuterGlow = ctx.createRadialGradient(
                centerX, centerY, baseRadius * 0.9,
                centerX, centerY, baseRadius * 1.8
            );

            // è®¡ç®—å…‰æ™•çš„å¼ºåº¦ç³»æ•° - æ ¹æ®éŸ³é¢‘å¼ºåº¦è°ƒæ•´
            const glowIntensity = Math.min(1, peakValue / 180); // å°†å³°å€¼å½’ä¸€åŒ–ä¸º0-1

            // ä½¿ç”¨å¤šä¸ªæ¸å˜ç‚¹åˆ›å»ºæ›´è‡ªç„¶çš„å…‰æ™•è¿‡æ¸¡ï¼Œå¹¶æ ¹æ®éŸ³é¢‘å¼ºåº¦è°ƒæ•´é€æ˜åº¦
            spectrumOuterGlow.addColorStop(0, rgba(colorScheme.mid, 0.35 * glowIntensity));
            spectrumOuterGlow.addColorStop(0.3, rgba(colorScheme.core, 0.25 * glowIntensity));
            spectrumOuterGlow.addColorStop(0.7, rgba(colorScheme.dark, 0.15 * glowIntensity));
            spectrumOuterGlow.addColorStop(1, rgba(colorScheme.darker, 0));
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = spectrumOuterGlow;
            ctx.fill();
            
            // --- ç»˜åˆ¶é¢‘è°±åˆ†æ®µ (å¢å¼ºç™½è‰²çº¿æ¡çš„è“è‰²å‘å…‰) ---
            ctx.lineWidth = 2.0; // æ›´ç²—çš„çº¿å®½
            ctx.lineJoin = 'round'; // åœ†æ»‘è¿æ¥
            ctx.miterLimit = 3;
            
            // åœ¨ç»˜åˆ¶é¢‘è°±æ—¶ï¼Œå…ˆç»˜åˆ¶å¤–éƒ¨å‘å…‰æ•ˆæœï¼Œå¢å¼ºè¾¹ç¼˜å…‰æ™•
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 20; // å¢åŠ æ¨¡ç³ŠåŠå¾„
            ctx.shadowColor = rgba(colorScheme.dark, 0.9);
    
            for (let i = 0; i < numVisualBars; i++) {
                const currentA = pointsA[i];
                const nextA = pointsA[(i + 1) % numVisualBars]; 
                const currentB = pointsB[i];
                const nextB = pointsB[(i + 1) % numVisualBars];

                ctx.beginPath();
                ctx.moveTo(currentA.x, currentA.y);
                ctx.lineTo(nextA.x, nextA.y);   
                ctx.lineTo(nextB.x, nextB.y);   
                ctx.lineTo(currentB.x, currentB.y); 
                ctx.closePath(); 

                const rawNormalizedValue = currentA.originalNormalizedValue;
                // å¢å¼ºå¤–ç¼˜å…‰æ™•æ•ˆæœ
                ctx.strokeStyle = rgba(colorScheme.core, 0.5 + rawNormalizedValue * 0.5);
                ctx.lineWidth = 2.5; // ç¨å¾®å¢åŠ çº¿å®½
                ctx.stroke();
            }
            
            // å†ç»˜åˆ¶ç™½è‰²çº¿æ¡æ ¸å¿ƒ
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 8;
            ctx.shadowColor = rgba(colorScheme.glow, 0.8);
            ctx.lineWidth = 1.2;
            
            for (let i = 0; i < numVisualBars; i++) {
                const currentA = pointsA[i];
                const nextA = pointsA[(i + 1) % numVisualBars]; 
                const currentB = pointsB[i];
                const nextB = pointsB[(i + 1) % numVisualBars];

                ctx.beginPath();
                ctx.moveTo(currentA.x, currentA.y);
                ctx.lineTo(nextA.x, nextA.y);   
                ctx.lineTo(nextB.x, nextB.y);   
                ctx.lineTo(currentB.x, currentB.y); 
                ctx.closePath(); 

                const rawNormalizedValue = currentA.originalNormalizedValue;
                // æ¸…æ™°çš„ç™½è‰²çº¿æ¡ - æ”¹ç”¨pointé¢œè‰²(çº¯ç™½)æˆ–lineé¢œè‰²(æ¥è¿‘ç™½)
                ctx.strokeStyle = rgba(colorScheme.point, 0.8 + rawNormalizedValue * 0.2);
                ctx.stroke();
            }
            
            // --- å¼ºè°ƒé¡¶ç‚¹ (æ”¹è¿›å…‰æ™•æ•ˆæœ) ---
            const pointRadiusBase = 0.75; // ç¼©å°åˆ°åŸæ¥çš„ä¸€åŠ
            const originalValueThreshold = 8;

            ctx.globalCompositeOperation = 'lighter';

            // ç»˜åˆ¶å¤–åœˆç‚¹ - æ›´æŸ”å’Œé€æ˜çš„å¤§èŒƒå›´å…‰æ™•
            for (let i = 0; i < numVisualBars; i++) {
                const rawNormA = pointsA[i].originalNormalizedValue;
                if (rawNormA * 255 > originalValueThreshold) {
                    // 1. æ›´å¤§èŒƒå›´çš„ææŸ”å’Œå…‰æ™•
                    const largeGlowRadius = pointRadiusBase * 30 + rawNormA * 40; // è¿›ä¸€æ­¥æ‰©å¤§å…‰æ™•åŠå¾„
                    const glow = ctx.createRadialGradient(
                        pointsA[i].x, pointsA[i].y, 0,
                        pointsA[i].x, pointsA[i].y, largeGlowRadius
                    );
                    // æ›´é€æ˜ã€æ›´æŸ”å’Œçš„å…‰æ™•è¿‡æ¸¡
                    glow.addColorStop(0, rgba(colorScheme.point, 0.6));  // é™ä½ä¸­å¿ƒä¸é€æ˜åº¦
                    glow.addColorStop(0.05, rgba(colorScheme.highlight, 0.4)); // æ›´å¿«çš„åˆå§‹è¿‡æ¸¡
                    glow.addColorStop(0.2, rgba(colorScheme.core, 0.15));     // æ›´é€æ˜
                    glow.addColorStop(0.5, rgba(colorScheme.core, 0.06));     // éå¸¸é€æ˜
                    glow.addColorStop(1, rgba(colorScheme.dark, 0));          // å®Œå…¨é€æ˜
                    
                    ctx.beginPath();
                    ctx.arc(pointsA[i].x, pointsA[i].y, largeGlowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = glow;
                    ctx.fill();
                    
                    // 2. ç¼©å°çš„ç™½è‰²å…‰ç‚¹æ ¸å¿ƒ
                    ctx.shadowBlur = 4; // å‡å°é˜´å½±æ¨¡ç³Š
                    ctx.shadowColor = rgba(colorScheme.point, 0.7); // æ›´é€æ˜çš„é˜´å½±
                    
                    ctx.beginPath();
                    ctx.arc(pointsA[i].x, pointsA[i].y, pointRadiusBase, 0, Math.PI * 2);
                    ctx.fillStyle = rgba(colorScheme.point, 0.9); // ç•¥å¾®é™ä½ä¸é€æ˜åº¦
                    ctx.fill();
                }
            }
            
            // å†…åœˆç‚¹ä¹ŸåŒæ ·å¤„ç†
            for (let i = 0; i < numVisualBars; i++) {
                const rawNormB = pointsB[i].originalNormalizedValue;
                if (rawNormB * 255 > originalValueThreshold) {
                    // å…‰æ™• - åŒæ ·æ›´å¤§æ›´æŸ”å’Œ
                    const glowRadius = pointRadiusBase * 20 + rawNormB * 24; // æ›´å¤§çš„å…‰æ™•
                    const glow = ctx.createRadialGradient(
                        pointsB[i].x, pointsB[i].y, 0,
                        pointsB[i].x, pointsB[i].y, glowRadius
                    );
                    // æ›´é€æ˜ã€æ›´æŸ”å’Œçš„è¿‡æ¸¡
                    glow.addColorStop(0, rgba(colorScheme.point, 0.5));
                    glow.addColorStop(0.1, rgba(colorScheme.highlight, 0.3));
                    glow.addColorStop(0.3, rgba(colorScheme.core, 0.12));
                    glow.addColorStop(0.7, rgba(colorScheme.core, 0.05));
                    glow.addColorStop(1, rgba(colorScheme.darker, 0));
                    
                    ctx.beginPath();
                    ctx.arc(pointsB[i].x, pointsB[i].y, glowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = glow;
                    ctx.fill();
                    
                    // æ ¸å¿ƒ - åŒæ ·ç¼©å°
                    ctx.shadowBlur = 3; // æ›´å°çš„é˜´å½±æ¨¡ç³Š
                    ctx.shadowColor = rgba(colorScheme.point, 0.6); // æ›´é€æ˜çš„é˜´å½±
                    
                    ctx.beginPath();
                    ctx.arc(pointsB[i].x, pointsB[i].y, pointRadiusBase * 0.4, 0, Math.PI * 2); // æ›´å°çš„æ ¸å¿ƒ
                    ctx.fillStyle = rgba(colorScheme.point, 0.85); // ç•¥å¾®é™ä½ä¸é€æ˜åº¦
                    ctx.fill();
                }
            }
            
            // æ¢å¤é»˜è®¤è®¾ç½®
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // --- ç²’å­æ•ˆæœ (ä¿®æ”¹é¢œè‰²ä»¥åŒ¹é…) ---
            if (peakValue > 180 && particles.length < MAX_PARTICLES && Math.random() < 0.3) { // å½“æœ‰å¼ºå³°å€¼æ—¶ç”Ÿæˆç²’å­
                 // ä»ä¸­å¿ƒæˆ–é¢‘è°±è¾¹ç¼˜ç”Ÿæˆç²’å­
                const spawnAngle = Math.random() * Math.PI * 2;
                const spawnRadius = baseRadius * (Math.random() * 0.5 + 0.8); // åœ¨é¢‘è°±é™„è¿‘
                const particleX = centerX + spawnRadius * Math.cos(spawnAngle);
                const particleY = centerY + spawnRadius * Math.sin(spawnAngle);
                particles.push(createParticle(particleX, particleY, 5 + peakValue / 255 * 10, null, peakValue/255 * 1.5));
            }
            updateAndDrawParticles();
        }

        // é¡µé¢åŠ è½½åè‡ªåŠ¨å¼€å§‹
        window.addEventListener('DOMContentLoaded', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼ŒéŸ³é¢‘å¯è§†åŒ–å‡†å¤‡å°±ç»ª');
            
            // åˆå§‹åŒ–å…¨å±€å˜é‡ï¼Œç”¨äºè·Ÿè¸ªå¤±è´¥é‡è¯•
            window.recentFailedMusic = '';
            window.recentFailedCount = 0;
            window.lastFetchTime = 0;
            
            // æ£€æŸ¥URLæ˜¯å¦åŒ…å«-testå‚æ•°
            if(window.location.href.includes('-test')) {
                // æ˜¾ç¤ºæ§åˆ¶åŒºåŸŸ
                document.getElementById('controls').style.display = 'flex';
            }
            
            // å»¶è¿Ÿä¸€ç‚¹åˆå§‹è·å–ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½
            setTimeout(() => {
                fetchCurrentMusic();
                // è®¾ç½®å®šæ—¶è·å–ï¼Œé—´éš”æ›´é•¿ä»¥é¿å…é¢‘ç¹è¯·æ±‚
                setInterval(fetchCurrentMusic, 10000); // æ”¹ä¸ºæ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
            }, 2000);
        });
        
        // ä¿®æ”¹å…¨å±€æ’­æ”¾å‡½æ•°ä¹Ÿæ£€æŸ¥æµ‹è¯•æ¨¡å¼
        window.playVisualizerMusic = function(musicPath) {
            loadAndPlayMusic(musicPath);
            
            // åªåœ¨æµ‹è¯•æ¨¡å¼ä¸‹æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
            if(window.location.href.includes('-test')) {
                statusInfo.textContent = `æ‰‹åŠ¨æ’­æ”¾: ${musicPath.split('/').pop()}`;
                statusInfo.style.display = 'block';
            }
        };
    </script>
</body>
</html>